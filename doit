#!/bin/sh

set -e

# Replace dc with U-Boot in the image

#old=/scratch/sglass/coral/chroot/build/coral/firmware/image-coral.dev.bin
old=/scratch/sglass/coral/chroot/build/coral/firmware/image-coral.bin

devkeys_dir=cros/data/devkeys

new=cb.bin
ub=/tmp/b/chromeos_coral
name=fallback/payload

cp $old $new

delete_locales() {
	for f in locale_tr.bin \
		locale_bg.bin \
		locale_hr.bin \
		locale_nl.bin \
		locale_ro.bin \
		locale_es.bin \
		locale_ja.bin \
		locale_el.bin \
		locale_pt-BR.bin \
		locale_de.bin \
		locale_lt.bin \
		locale_hi.bin \
		locale_vi.bin \
		locale_ca.bin \
		locale_hu.bin \
		locale_sr.bin \
		locale_pt-PT.bin \
		locale_fi.bin \
		locale_cs.bin \
		locale_he.bin \
		locale_fr.bin \
		locale_id.bin \
		locale_ta.bin \
		locale_bn.bin \
		locale_th.bin \
		locale_ar.bin \
		locale_it.bin \
		locale_pl.bin \
		locale_lv.bin \
		locale_mr.bin \
		locale_et.bin \
		locale_ms.bin \
		locale_nb.bin \
		locale_zh-CN.bin \
		locale_ko.bin \
		locale_fil.bin \
		locale_da.bin \
		locale_ru.bin \
		locale_uk.bin \
		locale_sl.bin \
		locale_te.bin \
		locale_sk.bin \
		locale_gu.bin \
		locale_sv.bin \
		locale_kn.bin \
		locale_ml.bin \
		locale_fa.bin \
		locale_zh-TW.bin \
		vbt-astronaut.bin vbt-epaulette.bin vbt-babytiger.bin \
		vbt-babymega.bin vbt-nasher.bin vbt-rabbid_rugged.bin; do
		cbfstool $new remove -n $f
	done

#	locale_es-419.bin \
}

# Process one region of the image
#  $1: region params ('' for recovery, '-r FW_MAIN_A' for firmare a)
do_part() {
	region="$1"

	cbfstool $new remove $region -n $name

	# Drop the unused bootblock in recovery to add space
	if [ -z "$region" ]; then
		 cbfstool $new remove $region -n bootblock
		delete_locales
	fi

	cbfstool $new expand $region

	if ! cbfstool $new add-flat-binary $region -n $name \
		-f $ub/u-boot.bin \
		-c lzma -l 0x1110000 -e 0x1110000; then
		cbfstool $new print $region
	fi
}

do_cbfstool() {
	local output
	output=$(cbfstool "$@" 2>&1)
	if [ $? != 0 ]; then
		die "Failed cbfstool invocation: cbfstool $@\n${output}"
	fi
	printf "${output}"
}

sign_region() {
	local fw_image=$1
	local keydir=$2
	local slot=$3

	local tmpfile=`mktemp`
	local cbfs=FW_MAIN_${slot}
	local vblock=VBLOCK_${slot}

	do_cbfstool ${fw_image} read -r ${cbfs} -f ${tmpfile}
	local size=$(do_cbfstool ${fw_image} print -k -r ${cbfs} | \
		tail -1 | \
		sed "/(empty).*null/ s,^(empty)[[:space:]]\(0x[0-9a-f]*\)\tnull\t.*$,\1,")
	size=$(printf "%d" ${size})

	# If the last entry is called "(empty)" and of type "null", remove it from
	# the section so it isn't part of the signed data, to improve boot speed
	# if (as often happens) there's a large unused suffix.
	if [ -n "${size}" ] && [ ${size} -gt 0 ]; then
		head -c ${size} ${tmpfile} > ${tmpfile}.2
		mv ${tmpfile}.2 ${tmpfile}
		# Use 255 (aka 0xff) as the filler, this greatly reduces
		# memory areas which need to be programmed for spi flash
		# chips, because the erase value is 0xff.
		do_cbfstool ${fw_image} write --force -u -i 255 \
			-r ${cbfs} -f ${tmpfile}
	fi

	futility vbutil_firmware \
		--vblock ${tmpfile}.out \
		--keyblock ${keydir}/firmware.keyblock \
		--signprivate ${keydir}/firmware_data_key.vbprivk \
		--version 1 \
		--fv ${tmpfile} \
		--kernelkey ${keydir}/kernel_subkey.vbpubk \
		--flags 0

	do_cbfstool ${fw_image} write -u -i 255 -r ${vblock} -f ${tmpfile}.out

	rm -f ${tmpfile} ${tmpfile}.out
}

sign_image() {
	local fw_image=$1
	local keydir=$2

	sign_region "${fw_image}" "${keydir}" A
	sign_region "${fw_image}" "${keydir}" B
}

# Do read/write and recovery
do_part "-r FW_MAIN_A"
do_part "-r FW_MAIN_B"
do_part

sign_image $new "${devkeys_dir}"


# Put valid MRC-cache data in there for a faster boot
cbfstool $new write -r RW_MRC_CACHE -f RW_MRC_CACHE
cbfstool $new write -r RW_VAR_MRC_CACHE -f RW_VAR_MRC_CACHE
cbfstool $new write -r RECOVERY_MRC_CACHE -f RECOVERY_MRC_CACHE
