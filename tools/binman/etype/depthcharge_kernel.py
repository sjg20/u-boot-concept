# SPDX-License-Identifier: GPL-2.0+
# Copyright (c) Alper Nebi Yasak <alpernebiyasak@gmail.com>
#
# Based on existing binman code:
# Copyright (c) 2018 Google, Inc
# Written by Simon Glass <sjg@chromium.org>
#
# Support for a Chromium OS verified boot kernel partition
#

from binman.entry import Entry, EntryArg

from patman import tools

class Entry_depthcharge_kernel(Entry):
    """Entry containing a Chromium OS verified boot kernel partition

    Chromium OS packs and signs its kernel, config and bootloader into a
    custom format and writes it to a GPT partition, which allows depthcharge
    to verify that the kernel and its parameters are genuine before booting
    it. This entry calls Chromium OS' futility tool to create this kind of
    'kernel' based on the inputs provided.

    For example:

        binman {
            depthcharge-kernel {
                keydir = "/usr/share/vboot/devkeys";
                keyblock = "kernel.keyblock";
                signprivate = "kernel_data_key.vbprivk";
                version = <1>;
                preamble-flags = <0>;
                arch = "arm";

                vmlinuz {
                    u-boot {
                    };
                };

                config {
                    text {
                        text = "";
                    };
                };

                bootloader {
                    text {
                        text = "";
                    };
                };
            };
        };

    Properties / Entry arguments:
        - keydir: Directory containing the public keys to use
        - keyblock: Name of the key file to use (inside keydir)
        - signprivate: Name of provide key file to use (inside keydir)
        - version: Version number of the vblock (typically 1)
        - arch: Cpu architecture (one of x86|amd64, arm|aarch64, mips)

    Optional properties / arguments:
        - preamble-flags: Value of the vboot preamble flags (typically 0)
        - kloadaddr: RAM address to load the kernel body (optional)
        - pad: Vblock padding size (optional)

    Image subsections:
        - vmlinuz: The kernel to sign and pack (typically a FIT image
          on arm architectures)
        - config: The kernel commandline file, up to 4096 bytes. If not
          given, an empty file is used.
        - bootloader: "Bootloader stub". If not given, an empty file is
          used.

    Output files:
        - <unique_name>.vmlinuz - input vmlinuz file passed to futility
        - <unique_name>.config - input config file passed to futility
        - <unique_name>.booloader - input bootloader file passed to futility
        - <unique_name>.kpart - output file generated by futility (which is
            used as the entry contents)
    """
    def __init__(self, section, etype, node):
        super().__init__(section, etype, node)
        (self.keydir, self.keyblock, self.signprivate, self.version,
         self.preamble_flags, self.arch, self.kloadaddr, self.vblock_pad,
        ) = self.GetEntryArgsOrProps([
            EntryArg('keydir', str),
            EntryArg('keyblock', str),
            EntryArg('signprivate', str),
            EntryArg('version', int),
            EntryArg('preamble-flags', int),
            EntryArg('arch', str),
            EntryArg('kloadaddr', int),
            EntryArg('vblock-pad', int),
        ])
        self._vmlinuz = None
        self._config = None
        self._bootloader = None

    def ReadNode(self):
        self._ReadSubnodes()
        super().ReadNode()

    def _ReadSubnodes(self):
        for node in self._node.subnodes:
            entry = Entry.Create(self.section, node, etype="section")
            entry.ReadNode()
            if node.name == 'vmlinuz':
                self._vmlinuz = entry
            elif node.name == 'config':
                self._config = entry
            elif node.name == 'bootloader':
                self._bootloader = entry
            else:
                self._Raise("Can't have a %s subsection" % node.name)
        if self._vmlinuz is None:
            self._Raise("Must have a vmlinuz subsection")

    def ObtainContents(self):
        uniq = self.GetUniqueName()
        vmlinuz_fname = tools.GetOutputFilename('%s.vmlinuz' % uniq)
        config_fname = tools.GetOutputFilename('%s.config' % uniq)
        bootloader_fname = tools.GetOutputFilename('%s.bootloader' % uniq)

        # Returns True or raises exception.
        self._vmlinuz.ObtainContents()
        self._vmlinuz.Pack(0)
        vmlinuz_data = self._vmlinuz.GetData()

        if self._config is not None:
            # Returns True or raises exception.
            self._config.ObtainContents()
            self._config.Pack(0)
            config_data = self._config.GetData()
        else:
            config_data = tools.GetBytes(0, 512)

        if self._bootloader is not None:
            # Returns True or raises exception.
            self._bootloader.ObtainContents()
            self._bootloader.Pack(0)
            bootloader_data = self._bootloader.GetData()
        else:
            bootloader_data = tools.GetBytes(0, 512)

        tools.WriteFile(vmlinuz_fname, vmlinuz_data)
        tools.WriteFile(config_fname, config_data)
        tools.WriteFile(bootloader_fname, bootloader_data)

        output_fname = tools.GetOutputFilename('%s.kpart' % uniq)
        prefix = self.keydir + '/'
        args = [
            'vbutil_kernel',
            '--pack', output_fname,
            '--keyblock', prefix + self.keyblock,
            '--signprivate', prefix + self.signprivate,
            '--version', '%d' % self.version,
            '--vmlinuz', vmlinuz_fname,
            '--bootloader', bootloader_fname,
            '--config', config_fname,
            '--arch', self.arch,
        ]
        if self.preamble_flags is not None:
            '--flags', '%d' % self.preamble_flags,
        if self.kloadaddr is not None:
            args += ['--kloadaddr', '%d' % self.kloadaddr]
        if self.vblock_pad is not None:
            args += ['--pad', '%d' % self.vblock_pad]
        stdout = tools.Run('futility', *args)

        self.SetContents(tools.ReadFile(output_fname))
        return True
