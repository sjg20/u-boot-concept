/*
 * Copyright (c) 2011 The Chromium OS Authors.
 *
 * See file CREDITS for list of people who contributed to this
 * project.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 * MA 02111-1307 USA
 */

Generic Relocation Framework
============================

Since most architectures perform relocation and mostly share the same
procedure, a generic relocation framework has been created.


What is Relocation?
-------------------
The basic purpose of relocation is to move U-Boot from its starting
address (probably CONFIG_SYS_TEXT_BASE) to the top the RAM. This makes
it easy to use the rest of available RAM in one chunk for things like
loading a kernel or ram disk.

The relocation code is in common/reloc.c in a function called
__relocate_code(). It is called right at the end of board_init_f() and
performs these steps:

- Copies U-Boot to the top of RAM
- Adjusts any code/data which needs relocation for the new position
- Clears our the BSS (so that your global variables start as zero!)
- Jumps to the new U-Boot, to a function called board_init_r()


How do I use the framework?
---------------------------
To use the generic framework, you should define a function for your
architecture in arch/xxx/include/asm/reloc.h like this:

/**
 * Process a single ELF relocation entry
 *
 * @param addr		Pointer to address of intruction/data to relocate
 * @param info		The ELF information word / flags
 * @param symtab	The ELF relocation symbol table
 * @param reloc_off	Offset of relocated U-Boot relative to load address
 * @return 0 if ok, -1 on error
 */
static inline int arch_elf_relocate_entry(Elf32_Addr *addr, Elf32_Word info,
			    Elf32_Sym *symtab, ulong reloc_off);


This function should relocate the code/data at the given relocated address
based on the relocation information in 'info'. The ELF symbol table and
relocation offset (new position minus CONFIG_SYS_TEXT_BASE) are provided.


How fast is relocation?
-----------------------
It's pretty fast, but if you want to speed up relocation, you can define
these two CONFIGs in your board file:

#define CONFIG_USE_ARCH_MEMSET - speeds up BSS clearing
#define CONFIG_USE_ARCH_MEMCPY - speeds up copying of code/data

Rough benchmarks on a Tegra2x ARM system showed that using both cut the total
relocation time by 65% (from 15ms to 5ms).


Opting Out
----------
If you want to do relocation yourself, you can define your own
relocate_code() function. See include/reloc.h for the prototype. You
can also define CONFIG_SYS_SKIP_RELOC to disable the generic relocation
and remove its code.
